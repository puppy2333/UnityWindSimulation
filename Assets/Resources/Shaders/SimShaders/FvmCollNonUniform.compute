#include "../Includes/Constants.hlsl"

// Each #kernel tells which function to compile; you can have many kernels
// ----- SIMPLE (accelerated) -----
#pragma kernel CSVelPredictPreCompute
#pragma kernel CSVelPredict
#pragma kernel CSPresCorrectRhieChowPreCompute
#pragma kernel CSPresCorrectRhieChow
#pragma kernel CSApplyPresCorrection
#pragma kernel CSPresNormalization
#pragma kernel CSApplyVelCorrectionDivergenceTheorem
// ----- Residual calculation -----
#pragma kernel CSComputeVelPredictResidual
#pragma kernel CSComputePresCorrectResidual


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture3D<float4> velField;
RWTexture3D<float4> velFieldLastTime;
RWTexture3D<float4> velFieldLastIter;
RWTexture3D<float4> velCorrectField;

RWTexture3D<float> presFieldLastTime;
RWTexture3D<float> presCorrectField;
RWTexture3D<float> presCorrectFieldLastIter;

RWTexture3D<float3> velFaceFluxField;

RWTexture3D<int> flagField; // 0 for fluid, 1 for solid

// ----- Velocity prediction Buffers -----
RWTexture3D<float4> DField;
RWTexture3D<float4> bField;

// ----- Pressure correction Buffers -----
RWTexture3D<float> DFieldPresCorrect;
RWTexture3D<float> bFieldPresCorrect;

// Buffer with size numGroupX * numGroupY * numGroupZ. Used to store the velocity / pressure 
// matrix residual of each thread group.
RWStructuredBuffer<float> gloResBuf;

// Aod * U correction field for PISO.
RWTexture3D<float4> AodUCorrectField;

// ----- Grid face position buffers -----
StructuredBuffer<float> facePosX;
StructuredBuffer<float> facePosY;
StructuredBuffer<float> facePosZ;

// ----- Boundary condition textures -----
// float4: (velX, velY, velZ, unused)
Texture2D<float4> bndFieldX0;
Texture2D<float4> bndFieldXn;
Texture2D<float4> bndFieldY0;
Texture2D<float4> bndFieldYn;
Texture2D<float4> bndFieldZ0;
Texture2D<float4> bndFieldZn;

int3 gridRes;
float dt;
float nu;
float den;
float3 externalForce;
int3 numGroups;

int velBndTypeX0;
int velBndTypeXn;
int velBndTypeY0;
int velBndTypeYn;
int velBndTypeZ0;
int velBndTypeZn;

int presBndTypeX0;
int presBndTypeXn;
int presBndTypeY0;
int presBndTypeYn;
int presBndTypeZ0;
int presBndTypeZn;

groupshared float groupResBuf[groupSize.x * groupSize.y * groupSize.z];

// ----- LES -----
bool useLES;
// Eddy viscosity field for LES simulation.
Texture3D<float> eddyVisField;

// ----- Return whether the cell with "id" is inside the simulation region -----
bool InRegion(int3 id)
{
    return (id.x >= 0 && id.x < gridRes.x) && (id.y >= 0 && id.y < gridRes.y) && (id.z >= 0 && id.z < gridRes.z);
}

bool IsFluid(int3 id)
{
    return flagField[id] == CELL_FLUID;
}

bool InRegionAndIsFluid(int3 id)
{
    if (InRegion(id))
        return flagField[id] == CELL_FLUID;
    else
        return false;
}

// ----- Velocity prediction pre compute step with LES model -----
// Called once per outer iteration, calculate Ad and b terms. These terms do not change between 
// inner iterations.
[numthreads(8, 8, 8)]
void CSVelPredictPreCompute(uint3 id : SV_DispatchThreadID)
{
    int x = id.x, y = id.y, z = id.z;
    
    if (!InRegion(id))
        return;
    
    if (flagField[int3(x, y, z)] != CELL_FLUID)
        return;
    
    int3 P = int3(x, y, z);
    int3 E = int3(x + 1, y, z);
    int3 W = int3(x - 1, y, z);
    int3 N = int3(x, y + 1, z);
    int3 S = int3(x, y - 1, z);
    int3 U = int3(x, y, z + 1);
    int3 D = int3(x, y, z - 1);
    
    // Grid spacings
    float dx = facePosX[x + 1] - facePosX[x];
    float dy = facePosY[y + 1] - facePosY[y];
    float dz = facePosZ[z + 1] - facePosZ[z];
    float dsx = dy * dz; // Area of surface perpendicular to x
    float dsy = dx * dz; // Area of surface perpendicular to y
    float dsz = dx * dy; // Area of surface perpendicular to z
    float dv = dx * dy * dz;
    
    // Neighbor grid spacings
    float dxE = dx, dxW = dx, dyN = dy, dyS = dy, dzU = dz, dzD = dz;
    if (InRegion(E))
        dxE = facePosX[x + 2] - facePosX[x + 1];
    if (InRegion(W))
        dxW = facePosX[x] - facePosX[x - 1];
    if (InRegion(N))
        dyN = facePosY[y + 2] - facePosY[y + 1];
    if (InRegion(S))
        dyS = facePosY[y] - facePosY[y - 1];
    if (InRegion(U))
        dzU = facePosZ[z + 2] - facePosZ[z + 1];
    if (InRegion(D))
        dzD = facePosZ[z] - facePosZ[z - 1];
    
    // ----- Linear interpolation weights -----
    // Naming convention:
    // wPe = weight for P cell east face interpolation
    // wE = weight for E cell interpolation (for the face between E and P, west face in this case)
    float wPe = dxE / (dx + dxE);
    float wE = 1.0f - wPe;
    
    float wPw = dxW / (dx + dxW);
    float wW = 1.0f - wPw;
    
    float wPn = dyN / (dy + dyN);
    float wN = 1.0f - wPn;
    
    float wPs = dyS / (dy + dyS);
    float wS = 1.0f - wPs;
    
    float wPu = dzU / (dz + dzU);
    float wU = 1.0f - wPu;
    
    float wPd = dzD / (dz + dzD);
    float wD = 1.0f - wPd;
    
    // Diagional terms
    float Dx = dv / dt, Dy = dv / dt, Dz = dv / dt;
    // b in Ax = b
    float bTermU = 0, bTermV = 0, bTermW = 0;
    
    // ----- Advection term -----
    // Central difference scheme (or linear interpolation) is used to calculate face velocity. 
    //
    // Discretization (use east face as an example):
    // U term: (ue' * ue) * ds
    // V term: (ve' * ue) * ds
    // W term: (we' * ue) * ds
    // ue' is step being solved, ue is the last iteration.
    // ue' * ue = (wP * uP' + wE * uE') * (wP * uP + wE * uE)
    // Ad (coefficient of uP) = wP * (wP * uP + wE * uE) (calculated here)
    // Aod (non-diagonal terms) = wE * uE' * (wP * uP + wE * uE), or nagative if moved to LHS. 
    // (recalculated in each iteration)
    //
    // Cases:
    // 1. E == fluid: normal treatment, update Ad and Aod,
    // 2. E == solid: ue = 0, therefore all the three terms = 0, no treatment needed,
    // 3. E == outside:
    //   3.1. Fixed value: all the terms are known, only update bterm,
    //   3.2. Zero gradient: ue = uP, ve = vP, we = wP, only update Ad, ue' * ue = uP' * uP, 
    //     ve' * ue = vP' * uP, we' * ue = wP' * uP,
    //   3.3. Symmetry: ue = 0, ve = vP, we = wP, all three terms = 0, no treatment needed.
    if (InRegionAndIsFluid(E))
    {
        Dx += dsx * wPe * velFaceFluxField[E].x;
        Dy += dsx * wPe * velFaceFluxField[E].x;
        Dz += dsx * wPe * velFaceFluxField[E].x;
    }
    else if (!InRegion(E))
    {
        if (velBndTypeXn == VEL_BND_FIXED_VALUE)
        {
            bTermU -= dsx * bndFieldXn[int2(y, z)].x * velFaceFluxField[E].x;
            bTermV -= dsx * bndFieldXn[int2(y, z)].y * velFaceFluxField[E].x;
            bTermW -= dsx * bndFieldXn[int2(y, z)].z * velFaceFluxField[E].x;
        }
        else if (velBndTypeXn == VEL_BND_ZERO_GRAD)
        {
            Dx += dsx * velFaceFluxField[E].x;
            Dy += dsx * velFaceFluxField[E].x;
            Dz += dsx * velFaceFluxField[E].x;
        }
    }
    
    // uw' * uw, vw' * uw, vw' * uw
    if (InRegionAndIsFluid(W))
    {
        Dx -= dsx * wPw * velFaceFluxField[P].x;
        Dy -= dsx * wPw * velFaceFluxField[P].x;
        Dz -= dsx * wPw * velFaceFluxField[P].x;
    }
    else if (!InRegion(W))
    {
        if (velBndTypeX0 == VEL_BND_FIXED_VALUE)
        {
            bTermU += dsx * bndFieldX0[int2(y, z)].x * velFaceFluxField[P].x;
            bTermV += dsx * bndFieldX0[int2(y, z)].y * velFaceFluxField[P].x;
            bTermW += dsx * bndFieldX0[int2(y, z)].z * velFaceFluxField[P].x;
        }
        else if (velBndTypeX0 == VEL_BND_ZERO_GRAD)
        {
            Dx -= dsx * velFaceFluxField[P].x;
            Dy -= dsx * velFaceFluxField[P].x;
            Dz -= dsx * velFaceFluxField[P].x;
        }
    }
    
    // un' * vn, vn' * vn, wn' * vn
    if (InRegionAndIsFluid(N))
    {
        Dx += dsy * wPn * velFaceFluxField[N].y;
        Dy += dsy * wPn * velFaceFluxField[N].y;
        Dz += dsy * wPn * velFaceFluxField[N].y;
    }
    else if (!InRegion(N))
    {
        if (velBndTypeYn == VEL_BND_FIXED_VALUE)
        {
            bTermU -= dsy * bndFieldYn[int2(x, z)].x * velFaceFluxField[N].y;
            bTermV -= dsy * bndFieldYn[int2(x, z)].y * velFaceFluxField[N].y;
            bTermW -= dsy * bndFieldYn[int2(x, z)].z * velFaceFluxField[N].y;
        }
        else if (velBndTypeYn == VEL_BND_ZERO_GRAD)
        {
            Dx += dsy * velFaceFluxField[N].y;
            Dy += dsy * velFaceFluxField[N].y;
            Dz += dsy * velFaceFluxField[N].y;
        }
    }
    
    // us' * vs, vs' * vs, ws' * vs
    if (InRegionAndIsFluid(S))
    {
        Dx -= dsy * wPs * velFaceFluxField[P].y;
        Dy -= dsy * wPs * velFaceFluxField[P].y;
        Dz -= dsy * wPs * velFaceFluxField[P].y;
    }
    else if (!InRegion(S))
    {
        if (velBndTypeY0 == VEL_BND_FIXED_VALUE)
        {
            bTermU += dsy * bndFieldY0[int2(x, z)].x * velFaceFluxField[P].y;
            bTermV += dsy * bndFieldY0[int2(x, z)].y * velFaceFluxField[P].y;
            bTermW += dsy * bndFieldY0[int2(x, z)].z * velFaceFluxField[P].y;
        }
        else if (velBndTypeY0 == VEL_BND_ZERO_GRAD)
        {
            Dx -= dsy * velFaceFluxField[P].y;
            Dy -= dsy * velFaceFluxField[P].y;
            Dz -= dsy * velFaceFluxField[P].y;
        }
    }
    
    // uu' * wu, vu' * wu, wu' * wu
    if (InRegionAndIsFluid(U))
    {
        Dx += dsz * wPu * velFaceFluxField[U].z;
        Dy += dsz * wPu * velFaceFluxField[U].z;
        Dz += dsz * wPu * velFaceFluxField[U].z;
    }
    else if (!InRegion(U))
    {
        if (velBndTypeZn == VEL_BND_FIXED_VALUE)
        {
            bTermU -= dsz * bndFieldZn[int2(x, y)].x * velFaceFluxField[U].z;
            bTermV -= dsz * bndFieldZn[int2(x, y)].y * velFaceFluxField[U].z;
            bTermW -= dsz * bndFieldZn[int2(x, y)].z * velFaceFluxField[U].z;
        }
        else if (velBndTypeZn == VEL_BND_ZERO_GRAD)
        {
            Dx += dsz * velFaceFluxField[U].z;
            Dy += dsz * velFaceFluxField[U].z;
            Dz += dsz * velFaceFluxField[U].z;
        }
    }
    
    // ud' * wd, vd' * wd, wd' * wd
    if (InRegionAndIsFluid(D))
    {
        Dx -= dsz * wPd * velFaceFluxField[P].z;
        Dy -= dsz * wPd * velFaceFluxField[P].z;
        Dz -= dsz * wPd * velFaceFluxField[P].z;
    }
    else if (!InRegion(D))
    {
        if (velBndTypeZ0 == VEL_BND_FIXED_VALUE)
        {
            bTermU += dsz * bndFieldZ0[int2(x, y)].x * velFaceFluxField[P].z;
            bTermV += dsz * bndFieldZ0[int2(x, y)].y * velFaceFluxField[P].z;
            bTermW += dsz * bndFieldZ0[int2(x, y)].z * velFaceFluxField[P].z;
        }
        else if (velBndTypeZ0 == VEL_BND_ZERO_GRAD)
        {
            Dx -= dsz * velFaceFluxField[P].z;
            Dy -= dsz * velFaceFluxField[P].z;
            Dz -= dsz * velFaceFluxField[P].z;
        }
    }
    
    // ----- Pressure term ----- 
    //
    // Discretization:
    // U term: -1/rho * (pe - pw) * ds
    // V term: -1/rho * (pn - ps) * ds
    // W term: -1/rho * (pu - pd) * ds
    // pe = wP * pP + wE * pE, the other terms are similar.
    // bTermU = -1/rho * (pe - pw) * ds
    // bTermV = -1/rho * (pe - pw) * ds
    // bTermW = -1/rho * (pe - pw) * ds
    //
    // Cases:
    // 1. E == fluid: pe = wP * pP + wE * pE,
    // 2. E == solid: pe = pP,
    // 3. E == outside:
    //   3.1. Fixed value: pe = 0,
    //   3.2. Zero gradient & Symmetry: pe = pP,
    float presEFace = 0, presWFace = 0, presNFace = 0, presSFace = 0, presUFace = 0, presDFace = 0;
    
    if (InRegion(E))
    {
        if (IsFluid(E))
            presEFace = wPe * presFieldLastTime[P] + wE * presFieldLastTime[E];
        else
            presEFace = presFieldLastTime[P];
    }
    else
    {
        if (presBndTypeXn == PRES_BND_FIXED_VALUE)
            presEFace = 0;
        else if (presBndTypeXn == PRES_BND_ZERO_GRAD)
            presEFace = presFieldLastTime[P];
        else if (presBndTypeXn == PRES_BND_SYMMETRY)
            presEFace = presFieldLastTime[P];
    }
    
    if (InRegion(W))
    {
        if (IsFluid(W))
            presWFace = wPw * presFieldLastTime[P] + wW * presFieldLastTime[W];
        else
            presWFace = presFieldLastTime[P];
    }
    else
    {
        if (presBndTypeX0 == PRES_BND_FIXED_VALUE)
            presWFace = 0;
        else if (presBndTypeX0 == PRES_BND_ZERO_GRAD)
            presWFace = presFieldLastTime[P];
        else if (presBndTypeX0 == PRES_BND_SYMMETRY)
            presWFace = presFieldLastTime[P];
    }
    
    if (InRegion(N))
    {
        if (IsFluid(N))
            presNFace = wPn * presFieldLastTime[P] + wN * presFieldLastTime[N];
        else
            presNFace = presFieldLastTime[P];
    }
    else
    {
        if (presBndTypeYn == PRES_BND_FIXED_VALUE)
            presNFace = 0;
        else if (presBndTypeYn == PRES_BND_ZERO_GRAD)
            presNFace = presFieldLastTime[P];
        else if (presBndTypeYn == PRES_BND_SYMMETRY)
            presNFace = presFieldLastTime[P];
    }
    
    if (InRegion(S))
    {
        if (IsFluid(S))
            presSFace = wPs * presFieldLastTime[P] + wS * presFieldLastTime[S];
        else
            presSFace = presFieldLastTime[P];
    }
    else
    {
        if (presBndTypeY0 == PRES_BND_FIXED_VALUE)
            presSFace = 0;
        else if (presBndTypeY0 == PRES_BND_ZERO_GRAD)
            presSFace = presFieldLastTime[P];
        else if (presBndTypeY0 == PRES_BND_SYMMETRY)
            presSFace = presFieldLastTime[P];
    }
    
    if (InRegion(U))
    {
        if (IsFluid(U))
            presUFace = wPu * presFieldLastTime[P] + wU * presFieldLastTime[U];
        else
            presUFace = presFieldLastTime[P];
    }
    else
    {
        if (presBndTypeZn == PRES_BND_FIXED_VALUE)
            presUFace = 0;
        else if (presBndTypeZn == PRES_BND_ZERO_GRAD)
            presUFace = presFieldLastTime[P];
        else if (presBndTypeZn == PRES_BND_SYMMETRY)
            presUFace = presFieldLastTime[P];
    }
    
    if (InRegion(D))
    {
        if (IsFluid(D))
            presDFace = wPd * presFieldLastTime[P] + wD * presFieldLastTime[D];
        else
            presDFace = presFieldLastTime[P];
    }
    else
    {
        if (presBndTypeZ0 == PRES_BND_FIXED_VALUE)
            presDFace = 0;
        else if (presBndTypeZ0 == PRES_BND_ZERO_GRAD)
            presDFace = presFieldLastTime[P];
        else if (presBndTypeZ0 == PRES_BND_SYMMETRY)
            presDFace = presFieldLastTime[P];
    }
    
    bTermU += -(1.0 / den) * dsx * (presEFace - presWFace);
    bTermV += -(1.0 / den) * dsy * (presNFace - presSFace);
    bTermW += -(1.0 / den) * dsz * (presUFace - presDFace);
    
    // ----- Diffusion term -----
    // Formula (use east face as an example):
    // U term: nu * (due/dx - duw/dx) * ds
    // V term: nu * (dvn/dx - dvs/dx) * ds
    // W term: nu * (dwn/dx - dws/dx) * ds
    //
    // Discretization:
    // due/dx = (uE - uP) / (0.5 * dx + 0.5 * dxE), the other terms are similar.
    //
    // Cases:
    // 1. E == fluid: normal treatment, update Ad and Aod,
    // 2. E == solid: ue = 0, therefore due/dx = -uP / (0.5 * dx), update Ad,
    // 3. E == outside:
    //   3.1. Fixed value: ue = uBoundary, therefore due/dx = (uBoundary - uP) / (0.5 * dx), 
    //     update Ad and bterm,
    //   3.2. Zero gradient: ue = uP, therefore due/dx = 0, no treatment needed,
    //   3.3. Symmetry: ue = 0, therefore due/dx = -uP / (0.5 * dx), update Ad(u), ve = vP, 
    //     therefore dve/dx = 0, no treatment needed, we is similar.
    
    // Calculate face viscosities with eddy viscosity included.
    float visEFace = nu, visWFace = nu, visNFace = nu, visSFace = nu, visUFace = nu, visDFace = nu;
    if (useLES)
    {
        visEFace = nu + eddyVisField[P];
        visWFace = nu + eddyVisField[P];
        visNFace = nu + eddyVisField[P];
        visSFace = nu + eddyVisField[P];
        visUFace = nu + eddyVisField[P];
        visDFace = nu + eddyVisField[P];
        if (InRegionAndIsFluid(E))
            visEFace = nu + wPe * eddyVisField[P] + wE * eddyVisField[E];
        if (InRegionAndIsFluid(W))
            visWFace = nu + wPw * eddyVisField[P] + wW * eddyVisField[W];
        if (InRegionAndIsFluid(N))
            visNFace = nu + wPn * eddyVisField[P] + wN * eddyVisField[N];
        if (InRegionAndIsFluid(S))
            visSFace = nu + wPs * eddyVisField[P] + wS * eddyVisField[S];
        if (InRegionAndIsFluid(U))
            visUFace = nu + wPu * eddyVisField[P] + wU * eddyVisField[U];
        if (InRegionAndIsFluid(D))
            visDFace = nu + wPd * eddyVisField[P] + wD * eddyVisField[D];
    }
    
    if (InRegion(E))
    {
        if (IsFluid(E))
        {
            Dx += visEFace * dsx / (0.5 * dx + 0.5 * dxE);
            Dy += visEFace * dsx / (0.5 * dx + 0.5 * dxE);
            Dz += visEFace * dsx / (0.5 * dx + 0.5 * dxE);
        }
        else
        {
            Dx += visEFace * dsx / (0.5 * dx);
            Dy += visEFace * dsx / (0.5 * dx);
            Dz += visEFace * dsx / (0.5 * dx);
        }
    }
    else
    {
        if (velBndTypeXn == VEL_BND_FIXED_VALUE)
        {
            bTermU += visEFace * dsx / (0.5 * dx) * bndFieldXn[int2(y, z)].x;
            bTermV += visEFace * dsx / (0.5 * dx) * bndFieldXn[int2(y, z)].y;
            bTermW += visEFace * dsx / (0.5 * dx) * bndFieldXn[int2(y, z)].z;
            Dx += visEFace * dsx / (0.5 * dx);
            Dy += visEFace * dsx / (0.5 * dx);
            Dz += visEFace * dsx / (0.5 * dx);
        }
        else if (velBndTypeXn == VEL_BND_SYMMETRY)
        {
            Dx += visEFace * dsx / (0.5 * dx);
        }
    }
    
    if (InRegion(W))
    {
        if (IsFluid(W))
        {
            Dx += visWFace * dsx / (0.5 * dx + 0.5 * dxW);
            Dy += visWFace * dsx / (0.5 * dx + 0.5 * dxW);
            Dz += visWFace * dsx / (0.5 * dx + 0.5 * dxW);
        }
        else
        {
            Dx += visWFace * dsx / (0.5 * dx);
            Dy += visWFace * dsx / (0.5 * dx);
            Dz += visWFace * dsx / (0.5 * dx);
        }
    }
    else
    {
        if (velBndTypeX0 == VEL_BND_FIXED_VALUE)
        {
            bTermU += visWFace * dsx / (0.5 * dx) * bndFieldX0[int2(y, z)].x;
            bTermV += visWFace * dsx / (0.5 * dx) * bndFieldX0[int2(y, z)].y;
            bTermW += visWFace * dsx / (0.5 * dx) * bndFieldX0[int2(y, z)].z;
            Dx += visWFace * dsx / (0.5 * dx);
            Dy += visWFace * dsx / (0.5 * dx);
            Dz += visWFace * dsx / (0.5 * dx);
        }
        else if (velBndTypeX0 == VEL_BND_SYMMETRY)
        {
            Dx += visWFace * dsx / (0.5 * dx);
        }
    }
    
    if (InRegion(N))
    {
        if (IsFluid(N))
        {
            Dx += visNFace * dsy / (0.5 * dy + 0.5 * dyN);
            Dy += visNFace * dsy / (0.5 * dy + 0.5 * dyN);
            Dz += visNFace * dsy / (0.5 * dy + 0.5 * dyN);
        }
        else
        {
            Dx += visNFace * dsy / (0.5 * dy);
            Dy += visNFace * dsy / (0.5 * dy);
            Dz += visNFace * dsy / (0.5 * dy);
        }
    }
    else
    {
        if (velBndTypeYn == VEL_BND_FIXED_VALUE)
        {
            bTermU += visNFace * dsy / (0.5 * dy) * bndFieldYn[int2(x, z)].x;
            bTermV += visNFace * dsy / (0.5 * dy) * bndFieldYn[int2(x, z)].y;
            bTermW += visNFace * dsy / (0.5 * dy) * bndFieldYn[int2(x, z)].z;
            Dx += visNFace * dsy / (0.5 * dy);
            Dy += visNFace * dsy / (0.5 * dy);
            Dz += visNFace * dsy / (0.5 * dy);
        }
        else if (velBndTypeYn == VEL_BND_SYMMETRY)
        {
            Dy += visNFace * dsy / (0.5 * dy);
        }
    }
    
    if (InRegion(S))
    {
        if (IsFluid(S))
        {
            Dx += visSFace * dsy / (0.5 * dy + 0.5 * dyS);
            Dy += visSFace * dsy / (0.5 * dy + 0.5 * dyS);
            Dz += visSFace * dsy / (0.5 * dy + 0.5 * dyS);
        }
        else
        {
            Dx += visSFace * dsy / (0.5 * dy);
            Dy += visSFace * dsy / (0.5 * dy);
            Dz += visSFace * dsy / (0.5 * dy);
        }
    }
    else
    {
        if (velBndTypeY0 == VEL_BND_FIXED_VALUE)
        {
            bTermU += visSFace * dsy / (0.5 * dy) * bndFieldY0[int2(x, z)].x;
            bTermV += visSFace * dsy / (0.5 * dy) * bndFieldY0[int2(x, z)].y;
            bTermW += visSFace * dsy / (0.5 * dy) * bndFieldY0[int2(x, z)].z;
            Dx += visSFace * dsy / (0.5 * dy);
            Dy += visSFace * dsy / (0.5 * dy);
            Dz += visSFace * dsy / (0.5 * dy);
        }
        else if (velBndTypeY0 == VEL_BND_SYMMETRY)
        {
            Dy += visSFace * dsy / (0.5 * dy);
        }
    }
    
    if (InRegion(U))
    {
        if (IsFluid(U))
        {
            Dx += visUFace * dsz / (0.5 * dz + 0.5 * dzU);
            Dy += visUFace * dsz / (0.5 * dz + 0.5 * dzU);
            Dz += visUFace * dsz / (0.5 * dz + 0.5 * dzU);
        }
        else
        {
            Dx += visUFace * dsz / (0.5 * dz);
            Dy += visUFace * dsz / (0.5 * dz);
            Dz += visUFace * dsz / (0.5 * dz);
        }
    }
    else
    {
        if (velBndTypeZn == VEL_BND_FIXED_VALUE)
        {
            bTermU += visUFace * dsz / (0.5 * dz) * bndFieldZn[int2(x, y)].x;
            bTermV += visUFace * dsz / (0.5 * dz) * bndFieldZn[int2(x, y)].y;
            bTermW += visUFace * dsz / (0.5 * dz) * bndFieldZn[int2(x, y)].z;
            Dx += visUFace * dsz / (0.5 * dz);
            Dy += visUFace * dsz / (0.5 * dz);
            Dz += visUFace * dsz / (0.5 * dz);
        }
        else if (velBndTypeZn == VEL_BND_SYMMETRY)
        {
            Dz += visUFace * dsz / (0.5 * dz);
        }
    }
    
    if (InRegion(D))
    {
        if (IsFluid(D))
        {
            Dx += visDFace * dsz / (0.5 * dz + 0.5 * dzD);
            Dy += visDFace * dsz / (0.5 * dz + 0.5 * dzD);
            Dz += visDFace * dsz / (0.5 * dz + 0.5 * dzD);
        }
        else
        {
            Dx += visDFace * dsz / (0.5 * dz);
            Dy += visDFace * dsz / (0.5 * dz);
            Dz += visDFace * dsz / (0.5 * dz);
        }
    }
    else
    {
        if (velBndTypeZ0 == VEL_BND_FIXED_VALUE)
        {
            bTermU += visDFace * dsz / (0.5 * dz) * bndFieldZ0[int2(x, y)].x;
            bTermV += visDFace * dsz / (0.5 * dz) * bndFieldZ0[int2(x, y)].y;
            bTermW += visDFace * dsz / (0.5 * dz) * bndFieldZ0[int2(x, y)].z;
            Dx += visDFace * dsz / (0.5 * dz);
            Dy += visDFace * dsz / (0.5 * dz);
            Dz += visDFace * dsz / (0.5 * dz);
        }
        else if (velBndTypeZ0 == VEL_BND_SYMMETRY)
        {
            Dz += visDFace * dsz / (0.5 * dz);
        }
    }
    
    // ----- Time derivative term -----
    bTermU += dv / dt * velFieldLastTime[P].x;
    bTermV += dv / dt * velFieldLastTime[P].y;
    bTermW += dv / dt * velFieldLastTime[P].z;
    
    // ----- Force term -----
    bTermU += dv * externalForce.x;
    bTermV += dv * externalForce.y;
    bTermW += dv * externalForce.z;
    
    // ----- LES term -----
    if (useLES)
    {
        bTermU += bField[P].x;
        bTermV += bField[P].y;
        bTermW += bField[P].z;
    }
    
    // Store the diagonal terms for A and b term, for velocity prediction and pressure correction.
    DField[id] = float4(Dx, Dy, Dz, 0.0f);
    bField[id] = float4(bTermU, bTermV, bTermW, 0.0f);
}

// ----- Velocity prediction step with LES model -----
// Called once per inner iteration, calculate Aod terms. Use precomputed Ad, b and Aod to update 
// velocity field.
[numthreads(8, 8, 8)]
void CSVelPredict(uint3 id : SV_DispatchThreadID)
{
    int x = id.x, y = id.y, z = id.z;
    
    if (!InRegion(id))
        return;
    
    if (flagField[int3(x, y, z)] != CELL_FLUID)
        return;
    
    float UAdvectTerm = 0, UPresTerm = 0, UDiffTerm = 0;
    float VAdvectTerm = 0, VPresTerm = 0, VDiffTerm = 0;
    float WAdvectTerm = 0, WPresTerm = 0, WDiffTerm = 0;
    
    int3 P = int3(x, y, z);
    int3 E = int3(x + 1, y, z);
    int3 W = int3(x - 1, y, z);
    int3 N = int3(x, y + 1, z);
    int3 S = int3(x, y - 1, z);
    int3 U = int3(x, y, z + 1);
    int3 D = int3(x, y, z - 1);
    
    // Grid spacings
    float dx = facePosX[x + 1] - facePosX[x];
    float dy = facePosY[y + 1] - facePosY[y];
    float dz = facePosZ[z + 1] - facePosZ[z];
    float dsx = dy * dz; // Area of surface perpendicular to x
    float dsy = dx * dz; // Area of surface perpendicular to y
    float dsz = dx * dy; // Area of surface perpendicular to z
    float dv = dx * dy * dz;
    
    // Neighbor grid spacings
    float dxE = dx, dxW = dx, dyN = dy, dyS = dy, dzU = dz, dzD = dz;
    if (InRegion(E))
        dxE = facePosX[x + 2] - facePosX[x + 1];
    if (InRegion(W))
        dxW = facePosX[x] - facePosX[x - 1];
    if (InRegion(N))
        dyN = facePosY[y + 2] - facePosY[y + 1];
    if (InRegion(S))
        dyS = facePosY[y] - facePosY[y - 1];
    if (InRegion(U))
        dzU = facePosZ[z + 2] - facePosZ[z + 1];
    if (InRegion(D))
        dzD = facePosZ[z] - facePosZ[z - 1];
    
    // ----- Linear interpolation weights -----
    // Naming convention:
    // wPe = weight for P cell east face interpolation
    // wE = weight for E cell interpolation (for the face between E and P, west face in this case)
    float wPe = dxE / (dx + dxE);
    float wE = 1.0f - wPe;
    
    float wPw = dxW / (dx + dxW);
    float wW = 1.0f - wPw;
    
    float wPn = dyN / (dy + dyN);
    float wN = 1.0f - wPn;
    
    float wPs = dyS / (dy + dyS);
    float wS = 1.0f - wPs;
    
    float wPu = dzU / (dz + dzU);
    float wU = 1.0f - wPu;
    
    float wPd = dzD / (dz + dzD);
    float wD = 1.0f - wPd;
    
    // ----- Advection term -----
    // Central difference scheme is used to calculate face velocity. 
    // ue' * ue, ve' * ue, we' * ue
    if (InRegionAndIsFluid(E))
    {
        UAdvectTerm -= dsx * wE * velFieldLastIter[E].x * velFaceFluxField[E].x;
        VAdvectTerm -= dsx * wE * velFieldLastIter[E].y * velFaceFluxField[E].x;
        WAdvectTerm -= dsx * wE * velFieldLastIter[E].z * velFaceFluxField[E].x;
    }
    
    // uw' * uw, vw' * uw, vw' * uw
    if (InRegionAndIsFluid(W))
    {
        UAdvectTerm += dsx * wW * velFieldLastIter[W].x * velFaceFluxField[P].x;
        VAdvectTerm += dsx * wW * velFieldLastIter[W].y * velFaceFluxField[P].x;
        WAdvectTerm += dsx * wW * velFieldLastIter[W].z * velFaceFluxField[P].x;
    }
    
    // un' * vn, vn' * vn, wn' * vn
    if (InRegionAndIsFluid(N))
    {
        UAdvectTerm -= dsy * wN * velFieldLastIter[N].x * velFaceFluxField[N].y;
        VAdvectTerm -= dsy * wN * velFieldLastIter[N].y * velFaceFluxField[N].y;
        WAdvectTerm -= dsy * wN * velFieldLastIter[N].z * velFaceFluxField[N].y;
    }
    
    // us' * vs, vs' * vs, ws' * vs
    if (InRegionAndIsFluid(S))
    {
        UAdvectTerm += dsy * wS * velFieldLastIter[S].x * velFaceFluxField[P].y;
        VAdvectTerm += dsy * wS * velFieldLastIter[S].y * velFaceFluxField[P].y;
        WAdvectTerm += dsy * wS * velFieldLastIter[S].z * velFaceFluxField[P].y;
    }
    
    // uu' * wu, vu' * wu, wu' * wu
    if (InRegionAndIsFluid(U))
    {
        UAdvectTerm -= dsz * wU * velFieldLastIter[U].x * velFaceFluxField[U].z;
        VAdvectTerm -= dsz * wU * velFieldLastIter[U].y * velFaceFluxField[U].z;
        WAdvectTerm -= dsz * wU * velFieldLastIter[U].z * velFaceFluxField[U].z;
    }
    
    // ud' * wd, vd' * wd, wd' * wd
    if (InRegionAndIsFluid(D))
    {
        UAdvectTerm += dsz * wD * velFieldLastIter[D].x * velFaceFluxField[P].z;
        VAdvectTerm += dsz * wD * velFieldLastIter[D].y * velFaceFluxField[P].z;
        WAdvectTerm += dsz * wD * velFieldLastIter[D].z * velFaceFluxField[P].z;
    }
    
    // ----- Diffusion term -----
    
    // Calculate face viscosities with eddy viscosity included.
    float visEFace = nu, visWFace = nu, visNFace = nu, visSFace = nu, visUFace = nu, visDFace = nu;
    if (useLES)
    {
        visEFace = nu + eddyVisField[P];
        visWFace = nu + eddyVisField[P];
        visNFace = nu + eddyVisField[P];
        visSFace = nu + eddyVisField[P];
        visUFace = nu + eddyVisField[P];
        visDFace = nu + eddyVisField[P];
        if (InRegionAndIsFluid(E))
            visEFace = nu + wPe * eddyVisField[P] + wE * eddyVisField[E];
        if (InRegionAndIsFluid(W))
            visWFace = nu + wPw * eddyVisField[P] + wW * eddyVisField[W];
        if (InRegionAndIsFluid(N))
            visNFace = nu + wPn * eddyVisField[P] + wN * eddyVisField[N];
        if (InRegionAndIsFluid(S))
            visSFace = nu + wPs * eddyVisField[P] + wS * eddyVisField[S];
        if (InRegionAndIsFluid(U))
            visUFace = nu + wPu * eddyVisField[P] + wU * eddyVisField[U];
        if (InRegionAndIsFluid(D))
            visDFace = nu + wPd * eddyVisField[P] + wD * eddyVisField[D];
    }
    
    if (InRegionAndIsFluid(E))
    {
        UDiffTerm += visEFace * dsx / (0.5 * dx + 0.5 * dxE) * velFieldLastIter[E].x;
        VDiffTerm += visEFace * dsx / (0.5 * dx + 0.5 * dxE) * velFieldLastIter[E].y;
        WDiffTerm += visEFace * dsx / (0.5 * dx + 0.5 * dxE) * velFieldLastIter[E].z;
    }
    
    if (InRegionAndIsFluid(W))
    {
        UDiffTerm += visWFace * dsx / (0.5 * dx + 0.5 * dxW) * velFieldLastIter[W].x;
        VDiffTerm += visWFace * dsx / (0.5 * dx + 0.5 * dxW) * velFieldLastIter[W].y;
        WDiffTerm += visWFace * dsx / (0.5 * dx + 0.5 * dxW) * velFieldLastIter[W].z;
    }
    
    if (InRegionAndIsFluid(N))
    {
        UDiffTerm += visNFace * dsy / (0.5 * dy + 0.5 * dyN) * velFieldLastIter[N].x;
        VDiffTerm += visNFace * dsy / (0.5 * dy + 0.5 * dyN) * velFieldLastIter[N].y;
        WDiffTerm += visNFace * dsy / (0.5 * dy + 0.5 * dyN) * velFieldLastIter[N].z;
    }
    
    if (InRegionAndIsFluid(S))
    {
        UDiffTerm += visSFace * dsy / (0.5 * dy + 0.5 * dyS) * velFieldLastIter[S].x;
        VDiffTerm += visSFace * dsy / (0.5 * dy + 0.5 * dyS) * velFieldLastIter[S].y;
        WDiffTerm += visSFace * dsy / (0.5 * dy + 0.5 * dyS) * velFieldLastIter[S].z;
    }
    
    if (InRegionAndIsFluid(U))
    {
        UDiffTerm += visUFace * dsz / (0.5 * dz + 0.5 * dzU) * velFieldLastIter[U].x;
        VDiffTerm += visUFace * dsz / (0.5 * dz + 0.5 * dzU) * velFieldLastIter[U].y;
        WDiffTerm += visUFace * dsz / (0.5 * dz + 0.5 * dzU) * velFieldLastIter[U].z;
    }
    
    if (InRegionAndIsFluid(D))
    {
        UDiffTerm += visDFace * dsz / (0.5 * dz + 0.5 * dzD) * velFieldLastIter[D].x;
        VDiffTerm += visDFace * dsz / (0.5 * dz + 0.5 * dzD) * velFieldLastIter[D].y;
        WDiffTerm += visDFace * dsz / (0.5 * dz + 0.5 * dzD) * velFieldLastIter[D].z;
    }
    
    // Calculate the final predicted velocities.
    float predictedVelX = 1.0 / DField[id].x * (UAdvectTerm + UDiffTerm + bField[id].x);
    float predictedVelY = 1.0 / DField[id].y * (VAdvectTerm + VDiffTerm + bField[id].y);
    float predictedVelZ = 1.0 / DField[id].z * (WAdvectTerm + WDiffTerm + bField[id].z);
    
    velField[id] = float4(predictedVelX, predictedVelY, predictedVelZ, 0.0f);
}

[numthreads(8, 8, 8)]
void CSPresCorrectRhieChowPreCompute(uint3 id : SV_DispatchThreadID)
{
    int x = id.x, y = id.y, z = id.z;
    
    if (!InRegion(id))
        return;
    
    if (flagField[id] != CELL_FLUID)
        return;

    int3 P = int3(x, y, z);
    int3 E = int3(x + 1, y, z);
    int3 W = int3(x - 1, y, z);
    int3 N = int3(x, y + 1, z);
    int3 S = int3(x, y - 1, z);
    int3 U = int3(x, y, z + 1);
    int3 D = int3(x, y, z - 1);
    
    int3 EE = int3(x + 2, y, z);
    int3 WW = int3(x - 2, y, z);
    int3 NN = int3(x, y + 2, z);
    int3 SS = int3(x, y - 2, z);
    int3 UU = int3(x, y, z + 2);
    int3 DD = int3(x, y, z - 2);
    
    // Grid spacings
    float dx = facePosX[x + 1] - facePosX[x];
    float dy = facePosY[y + 1] - facePosY[y];
    float dz = facePosZ[z + 1] - facePosZ[z];
    float dsx = dy * dz; // Area of surface perpendicular to x
    float dsy = dx * dz; // Area of surface perpendicular to y
    float dsz = dx * dy; // Area of surface perpendicular to z
    float dv = dx * dy * dz;
    
    // Neighbor grid spacings
    float dxE = dx, dxW = dx, dyN = dy, dyS = dy, dzU = dz, dzD = dz;
    if (InRegion(E))
        dxE = facePosX[x + 2] - facePosX[x + 1];
    if (InRegion(W))
        dxW = facePosX[x] - facePosX[x - 1];
    if (InRegion(N))
        dyN = facePosY[y + 2] - facePosY[y + 1];
    if (InRegion(S))
        dyS = facePosY[y] - facePosY[y - 1];
    if (InRegion(U))
        dzU = facePosZ[z + 2] - facePosZ[z + 1];
    if (InRegion(D))
        dzD = facePosZ[z] - facePosZ[z - 1];
    
    // Neighbor of neighbor grid spacings
    float dxEE = dx, dxWW = dx, dyNN = dy, dySS = dy, dzUU = dz, dzDD = dz;
    if (InRegion(EE))
        dxEE = facePosX[x + 3] - facePosX[x + 2];
    if (InRegion(WW))
        dxWW = facePosX[x - 1] - facePosX[x - 2];
    if (InRegion(NN))
        dyNN = facePosY[y + 3] - facePosY[y + 2];
    if (InRegion(SS))
        dySS = facePosY[y - 1] - facePosY[y - 2];
    if (InRegion(UU))
        dzUU = facePosZ[z + 3] - facePosZ[z + 2];
    if (InRegion(DD))
        dzDD = facePosZ[z - 1] - facePosZ[z - 2];
    
    float uFaceE = 0, uFaceW = 0, vFaceN = 0, vFaceS = 0, wFaceU = 0, wFaceD = 0;
    
    // Dp & bp: Diagonal term of A & b term of pressure correction equation.
    float Dp = 0;
    float bp = 0;
    
    // Formula:
    // dv/den * (dpe'/dx - dpw'/dx + dpn'/dy - dps'/dy + dpu'/dz - dpd'/dz) = ue* - uw* + vn* - vs* + wu* - wd*
    // where pi' is the pressure correction, and ui*, vi*, wi* are the predicted velocities.
    // Discretization:
    // 1. E == fluid: dpe'/dx = (pE' - pP') / (0.5*dx + 0.5*dxE), ue* = wP*uP + wE*uE
    // 2. E == solid: dpe'/dx = 0, ue* = 0
    // 3. E == boundary:
    //   3.1. (p) Fixed value: dpe'/dx = -pP' / (0.5 * dx)
    //   3.2. (p) Zero-gradient or symmetry: dpe'/dx = 0
    //   3.3. (u) Fixed value: ue* = uBnd
    //   3.4. (u) Zero-gradient: ue* = uP
    //   3.5. (u) Symmetry: ue* = 0
    
    if (InRegion(E))
    {
        if (IsFluid(E))
        {
            // Weights for linear interpolation
            float wP = dxE / (dx + dxE);
            float wE = 1.0f - wP;
            
            float DInv = wP * (1 / DField[P].x) + wE * (1 / DField[E].x);
        
            // CDS interpolation
            Dp -= (dv / den) * DInv / (0.5 * dx + 0.5 * dxE);
            uFaceE = wP * velField[P].x + wE * velField[E].x;
        
            // Rhie-Chow correction
            float presGrad = (presFieldLastTime[E] - presFieldLastTime[P]) / (0.5 * dx + 0.5 * dxE);
            float presGradAve = 0;
        
            if (InRegionAndIsFluid(EE) && InRegionAndIsFluid(W))
                presGradAve = 0.5 * ((presFieldLastTime[EE] - presFieldLastTime[P]) / (0.5 * dxEE + dxE + 0.5 * dx) + (presFieldLastTime[E] - presFieldLastTime[W]) / (0.5 * dxE + dx + 0.5 * dxW));
            else if (InRegionAndIsFluid(EE))
                presGradAve = 0.5 * ((presFieldLastTime[EE] - presFieldLastTime[P]) / (0.5 * dxEE + dxE + 0.5 * dx) + (presFieldLastTime[E] - presFieldLastTime[P]) / (0.5 * dxE + 1.5 * dx));
            else if (InRegionAndIsFluid(W))
                presGradAve = 0.5 * ((presFieldLastTime[E] - presFieldLastTime[P]) / (1.5 * dxE + 0.5 * dx) + (presFieldLastTime[E] - presFieldLastTime[W]) / (0.5 * dxE + dx + 0.5 * dxW));
            else
                presGradAve = presGrad;
        
            uFaceE -= (dv * DInv) / den * (presGrad - presGradAve);
            bp += uFaceE;
        }
        // Solid cell does not need explicit treatment.
    }
    else
    {
        // ----- Velocity boundary -----
        if (velBndTypeXn == VEL_BND_FIXED_VALUE)
        {
            uFaceE = bndFieldXn[int2(y, z)].x;
            bp += bndFieldXn[int2(y, z)].x;
        }
        else if (velBndTypeXn == VEL_BND_ZERO_GRAD)
        {
            uFaceE = velField[P].x;
            bp += velField[P].x;
        }
        // Symmetry velocity boundary does not need explicit treatment.
        
        // ----- Pressure boundary -----
        if (presBndTypeXn == PRES_BND_FIXED_VALUE)
        {
            float DInv = 1 / DField[P].x;
            Dp -= (dv / den) * DInv / (0.5 * dx);
        }
        // Zero-gradient and symmetry pressure boundary do not need explicit treatment.
    }
    
    if (InRegion(W))
    {
        if (IsFluid(W))
        {
            // Weights for linear interpolation
            float wP = dxW / (dx + dxW);
            float wW = 1.0f - wP;
            
            float DInv = wP * (1 / DField[P].x) + wW * (1 / DField[W].x);
        
            // CDS interpolation
            Dp -= (dv / den) * DInv / (0.5 * dx + 0.5 * dxW);
            uFaceW = wP * velField[P].x + wW * velField[W].x;
        
            // Rhie-Chow correction
            float presGrad = (presFieldLastTime[P] - presFieldLastTime[W]) / (0.5 * dx + 0.5 * dxW);
            float presGradAve = 0;
        
            if (InRegionAndIsFluid(WW) && InRegionAndIsFluid(E))
                presGradAve = 0.5 * ((presFieldLastTime[E] - presFieldLastTime[W]) / (0.5 * dxE + dx + 0.5 * dxW) + (presFieldLastTime[P] - presFieldLastTime[WW]) / (0.5 * dx + dxW + 0.5 * dxWW));
            else if (InRegionAndIsFluid(WW))
                presGradAve = 0.5 * ((presFieldLastTime[P] - presFieldLastTime[W]) / (1.5 * dx + 0.5 * dxW) + (presFieldLastTime[P] - presFieldLastTime[WW]) / (0.5 * dx + dxW + 0.5 * dxWW));
            else if (InRegionAndIsFluid(E))
                presGradAve = 0.5 * ((presFieldLastTime[E] - presFieldLastTime[W]) / (0.5 * dxE + dx + 0.5 * dxW) + (presFieldLastTime[P] - presFieldLastTime[W]) / (0.5 * dx + 1.5 * dxW));
            else
                presGradAve = presGrad;
        
            uFaceW -= (dv * DInv) / den * (presGrad - presGradAve);
            bp -= uFaceW;
        }
    }
    else
    {
        // ----- Velocity boundary -----
        if (velBndTypeX0 == VEL_BND_FIXED_VALUE)
        {
            uFaceW = bndFieldX0[int2(y, z)].x;
            bp -= bndFieldX0[int2(y, z)].x;
        }
        else if (velBndTypeX0 == VEL_BND_ZERO_GRAD)
        {
            uFaceW = velField[P].x;
            bp -= velField[P].x;
        }
        // Symmetry velocity boundary does not need explicit treatment.
        
        // ----- Pressure boundary -----
        if (presBndTypeX0 == PRES_BND_FIXED_VALUE)
        {
            float DInv = 1 / DField[P].x;
            Dp -= (dv / den) * DInv / (0.5 * dx);
        }
        // Zero-gradient and symmetry pressure boundary do not need explicit treatment.
    }
    
    if (InRegion(N))
    {
        if (IsFluid(N))
        {
            // Weights for linear interpolation
            float wP = dyN / (dy + dyN);
            float wN = 1.0f - wP;
            
            float DInv = wP * (1 / DField[P].y) + wN * (1 / DField[N].y);
        
            // CDS interpolation
            Dp -= (dv / den) * DInv / (0.5 * dy + 0.5 * dyN);
            vFaceN = wP * velField[P].y + wN * velField[N].y;
        
            // Rhie-Chow correction
            float presGrad = (presFieldLastTime[N] - presFieldLastTime[P]) / (0.5 * dy + 0.5 * dyN);
            float presGradAve = 0;
        
            if (InRegionAndIsFluid(NN) && InRegionAndIsFluid(S))
                presGradAve = 0.5 * ((presFieldLastTime[NN] - presFieldLastTime[P]) / (0.5 * dyNN + dyN + 0.5 * dy) + (presFieldLastTime[N] - presFieldLastTime[S]) / (0.5 * dyN + dy + 0.5 * dyS));
            else if (InRegionAndIsFluid(NN))
                presGradAve = 0.5 * ((presFieldLastTime[NN] - presFieldLastTime[P]) / (0.5 * dyNN + dyN + 0.5 * dy) + (presFieldLastTime[N] - presFieldLastTime[P]) / (0.5 * dyN + 1.5 * dy));
            else if (InRegionAndIsFluid(S))
                presGradAve = 0.5 * ((presFieldLastTime[N] - presFieldLastTime[P]) / (1.5 * dyN + 0.5 * dy) + (presFieldLastTime[N] - presFieldLastTime[S]) / (0.5 * dyN + dy + 0.5 * dyS));
            else
                presGradAve = presGrad;
        
            vFaceN -= (dv * DInv) / den * (presGrad - presGradAve);
            bp += vFaceN;
        }
    }
    else
    {
        // ----- Velocity boundary -----
        if (velBndTypeYn == VEL_BND_FIXED_VALUE)
        {
            vFaceN += bndFieldYn[int2(x, z)].y;
            bp += bndFieldYn[int2(x, z)].y;
        }
        else if (velBndTypeYn == VEL_BND_ZERO_GRAD)
        {
            vFaceN += velField[P].y;
            bp += velField[P].y;
        }
        // Symmetry velocity boundary does not need explicit treatment.
        
        // ----- Pressure boundary -----
        if (presBndTypeYn == PRES_BND_FIXED_VALUE)
        {
            float DInv = 1 / DField[P].y;
            Dp -= (dv / den) * DInv / (0.5 * dy);
        }
        // Zero-gradient and symmetry pressure boundary do not need explicit treatment.
    }
    
    if (InRegion(S))
    {
        if (IsFluid(S))
        {
            // Weights for linear interpolation
            float wP = dyS / (dy + dyS);
            float wS = 1.0f - wP;
            
            float DInv = wP * (1 / DField[P].y) + wS * (1 / DField[S].y);
        
            // CDS interpolation
            Dp -= (dv / den) * DInv / (0.5 * dy + 0.5 * dyS);
            vFaceS = wP * velField[P].y + wS * velField[S].y;
        
            // Rhie-Chow correction
            float presGrad = (presFieldLastTime[P] - presFieldLastTime[S]) / (0.5 * dy + 0.5 * dyS);
            float presGradAve = 0;
        
            if (InRegionAndIsFluid(SS) && InRegionAndIsFluid(N))
                presGradAve = 0.5 * ((presFieldLastTime[N] - presFieldLastTime[S]) / (0.5 * dyN + dy + 0.5 * dyS) + (presFieldLastTime[P] - presFieldLastTime[SS]) / (0.5 * dy + dyS + 0.5 * dySS));
            else if (InRegionAndIsFluid(SS))
                presGradAve = 0.5 * ((presFieldLastTime[P] - presFieldLastTime[S]) / (1.5 * dy + 0.5 * dyS) + (presFieldLastTime[P] - presFieldLastTime[SS]) / (0.5 * dy + dyS + 0.5 * dySS));
            else if (InRegionAndIsFluid(N))
                presGradAve = 0.5 * ((presFieldLastTime[N] - presFieldLastTime[S]) / (0.5 * dyN + dy + 0.5 * dyS) + (presFieldLastTime[P] - presFieldLastTime[S]) / (0.5 * dy + 1.5 * dyS));
            else
                presGradAve = presGrad;
        
            vFaceS -= (dv * DInv) / den * (presGrad - presGradAve);
            bp -= vFaceS;
        }
    }
    else
    {
        // ----- Velocity boundary -----
        if (velBndTypeY0 == VEL_BND_FIXED_VALUE)
        {
            vFaceS = bndFieldY0[int2(x, z)].y;
            bp -= bndFieldY0[int2(x, z)].y;
        }
        else if (velBndTypeY0 == VEL_BND_ZERO_GRAD)
        {
            vFaceS = velField[P].y;
            bp -= velField[P].y;
        }
        // Symmetry velocity boundary does not need explicit treatment.
        
        // ----- Pressure boundary -----
        if (presBndTypeY0 == PRES_BND_FIXED_VALUE)
        {
            float DInv = 1 / DField[P].y;
            Dp -= (dv / den) * DInv / (0.5 * dy);
        }
        // Zero-gradient and symmetry pressure boundary do not need explicit treatment.
    }
    
    if (InRegion(U))
    {
        if (IsFluid(U))
        {
            // Weights for linear interpolation
            float wP = dzU / (dz + dzU);
            float wU = 1.0f - wP;
            
            float DInv = wP * (1 / DField[P].z) + wU * (1 / DField[U].z);
        
            // CDS interpolation
            Dp -= (dv / den) * DInv / (0.5 * dz + 0.5 * dzU);
            wFaceU = wP * velField[P].z + wU * velField[U].z;
        
            // Rhie-Chow correction
            float presGrad = (presFieldLastTime[U] - presFieldLastTime[P]) / (0.5 * dz + 0.5 * dzU);
            float presGradAve = 0;
        
            if (InRegionAndIsFluid(UU) && InRegionAndIsFluid(D))
                presGradAve = 0.5 * ((presFieldLastTime[UU] - presFieldLastTime[P]) / (0.5 * dzUU + dzU + 0.5 * dz) + (presFieldLastTime[U] - presFieldLastTime[D]) / (0.5 * dzU + dz + 0.5 * dzD));
            else if (InRegionAndIsFluid(UU))
                presGradAve = 0.5 * ((presFieldLastTime[UU] - presFieldLastTime[P]) / (0.5 * dzUU + dzU + 0.5 * dz) + (presFieldLastTime[U] - presFieldLastTime[P]) / (0.5 * dzU + 1.5 * dz));
            else if (InRegionAndIsFluid(D))
                presGradAve = 0.5 * ((presFieldLastTime[U] - presFieldLastTime[P]) / (1.5 * dzU + 0.5 * dz) + (presFieldLastTime[U] - presFieldLastTime[D]) / (0.5 * dzU + dz + 0.5 * dzD));
            else
                presGradAve = presGrad;
        
            wFaceU -= (dv * DInv) / den * (presGrad - presGradAve);
            bp += wFaceU;
        }
    }
    else
    {
        // ----- Velocity boundary -----
        if (velBndTypeZn == VEL_BND_FIXED_VALUE)
        {
            wFaceU = bndFieldZn[int2(x, y)].z;
            bp += bndFieldZn[int2(x, y)].z;
        }
        else if (velBndTypeZn == VEL_BND_ZERO_GRAD)
        {
            wFaceU = velField[P].z;
            bp += velField[P].z;
        }
        // Symmetry velocity boundary does not need explicit treatment.
        
        // ----- Pressure boundary -----
        if (presBndTypeZn == PRES_BND_FIXED_VALUE)
        {
            float DInv = 1 / DField[P].z;
            Dp -= (dv / den) * DInv / (0.5 * dz);
        }
        // Zero-gradient and symmetry pressure boundary do not need explicit treatment.
    }
    
    if (InRegion(D))
    {
        if (IsFluid(D))
        {
            // Weights for linear interpolation
            float wP = dzD / (dz + dzD);
            float wD = 1.0f - wP;
            
            float DInv = wP * (1 / DField[P].z) + wD * (1 / DField[D].z);
        
            // CDS interpolation
            Dp -= (dv / den) * DInv / (0.5 * dz + 0.5 * dzD);
            wFaceD = wP * velField[P].z + wD * velField[D].z;
        
            // Rhie-Chow correction
            float presGrad = (presFieldLastTime[P] - presFieldLastTime[D]) / (0.5 * dz + 0.5 * dzD);
            float presGradAve = 0;
        
            if (InRegionAndIsFluid(DD) && InRegionAndIsFluid(U))
                presGradAve = 0.5 * ((presFieldLastTime[U] - presFieldLastTime[D]) / (0.5 * dzU + dz + 0.5 * dzD) + (presFieldLastTime[P] - presFieldLastTime[DD]) / (0.5 * dz + dzD + 0.5 * dzDD));
            else if (InRegionAndIsFluid(DD))
                presGradAve = 0.5 * ((presFieldLastTime[P] - presFieldLastTime[D]) / (1.5 * dz + 0.5 * dzD) + (presFieldLastTime[P] - presFieldLastTime[DD]) / (0.5 * dz + dzD + 0.5 * dzDD));
            else if (InRegionAndIsFluid(U))
                presGradAve = 0.5 * ((presFieldLastTime[U] - presFieldLastTime[D]) / (0.5 * dzU + dz + 0.5 * dzD) + (presFieldLastTime[P] - presFieldLastTime[D]) / (0.5 * dz + 1.5 * dzD));
            else
                presGradAve = presGrad;
        
            wFaceD -= (dv * DInv) / den * (presGrad - presGradAve);
            bp -= wFaceD;
        }
    }
    else
    {
        // ----- Velocity boundary -----
        if (velBndTypeZ0 == VEL_BND_FIXED_VALUE)
        {
            wFaceD = bndFieldZ0[int2(x, y)].z;
            bp -= bndFieldZ0[int2(x, y)].z;
        }
        else if (velBndTypeZ0 == VEL_BND_ZERO_GRAD)
        {
            wFaceD = velField[P].z;
            bp -= velField[P].z;
        }
        // Symmetry velocity boundary does not need explicit treatment.
        
        // ----- Pressure boundary -----
        if (presBndTypeZ0 == PRES_BND_FIXED_VALUE)
        {
            float DInv = 1 / DField[P].z;
            Dp -= (dv / den) * DInv / (0.5 * dz);
        }
        // Zero-gradient and symmetry pressure boundary do not need explicit treatment.
    }
    
    velFaceFluxField[id] = float3(uFaceW, vFaceS, wFaceD);
    if (!InRegion(E))
        velFaceFluxField[E] = float3(uFaceE, 0, 0);
    if (!InRegion(N))
        velFaceFluxField[N] = float3(0, vFaceN, 0);
    if (!InRegion(U))
        velFaceFluxField[U] = float3(0, 0, wFaceU);
    DFieldPresCorrect[id] = Dp;
    bFieldPresCorrect[id] = bp;
}

[numthreads(8, 8, 8)]
void CSPresCorrectRhieChow(uint3 id : SV_DispatchThreadID)
{
    int x = id.x, y = id.y, z = id.z;
    
    if (!InRegion(id))
        return;
    
    if (flagField[id] != CELL_FLUID)
        return;

    int3 P = int3(x, y, z);
    int3 E = int3(x + 1, y, z);
    int3 W = int3(x - 1, y, z);
    int3 N = int3(x, y + 1, z);
    int3 S = int3(x, y - 1, z);
    int3 U = int3(x, y, z + 1);
    int3 D = int3(x, y, z - 1);
    
    // Grid spacings
    float dx = facePosX[x + 1] - facePosX[x];
    float dy = facePosY[y + 1] - facePosY[y];
    float dz = facePosZ[z + 1] - facePosZ[z];
    float dsx = dy * dz; // Area of surface perpendicular to x
    float dsy = dx * dz; // Area of surface perpendicular to y
    float dsz = dx * dy; // Area of surface perpendicular to z
    float dv = dx * dy * dz;
    
    // Neighbor grid spacings
    float dxE = dx, dxW = dx, dyN = dy, dyS = dy, dzU = dz, dzD = dz;
    if (InRegion(E))
        dxE = facePosX[x + 2] - facePosX[x + 1];
    if (InRegion(W))
        dxW = facePosX[x] - facePosX[x - 1];
    if (InRegion(N))
        dyN = facePosY[y + 2] - facePosY[y + 1];
    if (InRegion(S))
        dyS = facePosY[y] - facePosY[y - 1];
    if (InRegion(U))
        dzU = facePosZ[z + 2] - facePosZ[z + 1];
    if (InRegion(D))
        dzD = facePosZ[z] - facePosZ[z - 1];
    
    // Solve the continuity equation to obtain pressure correction.
    float presCorrectTerm = 0;
    
    if (InRegionAndIsFluid(E))
    {
        // Weights for linear interpolation
        float wP = dxE / (dx + dxE);
        float wE = 1.0f - wP;
        
        float DInv = wP * (1 / DField[P].x) + wE * (1 / DField[E].x);
        presCorrectTerm -= (dv / den) * DInv / (0.5 * dx + 0.5 * dxE) * presCorrectFieldLastIter[E];
    }
    
    if (InRegionAndIsFluid(W))
    {
        // Weights for linear interpolation
        float wP = dxW / (dx + dxW);
        float wW = 1.0f - wP;
        
        float DInv = wP * (1 / DField[P].x) + wW * (1 / DField[W].x);
        presCorrectTerm -= (dv / den) * DInv / (0.5 * dx + 0.5 * dxW) * presCorrectFieldLastIter[W];
    }
    
    if (InRegionAndIsFluid(N))
    {
        // Weights for linear interpolation
        float wP = dyN / (dy + dyN);
        float wN = 1.0f - wP;
        
        float DInv = wP * (1 / DField[P].y) + wN * (1 / DField[N].y);
        presCorrectTerm -= (dv / den) * DInv / (0.5 * dy + 0.5 * dyN) * presCorrectFieldLastIter[N];
    }
    
    if (InRegionAndIsFluid(S))
    {
        // Weights for linear interpolation
        float wP = dyS / (dy + dyS);
        float wS = 1.0f - wP;
        
        float DInv = wP * (1 / DField[P].y) + wS * (1 / DField[S].y);
        presCorrectTerm -= (dv / den) * DInv / (0.5 * dy + 0.5 * dyS) * presCorrectFieldLastIter[S];
    }
    
    if (InRegionAndIsFluid(U))
    {
        // Weights for linear interpolation
        float wP = dzU / (dz + dzU);
        float wU = 1.0f - wP;
        
        float DInv = wP * (1 / DField[P].z) + wU * (1 / DField[U].z);
        presCorrectTerm -= (dv / den) * DInv / (0.5 * dz + 0.5 * dzU) * presCorrectFieldLastIter[U];
    }
    
    if (InRegionAndIsFluid(D))
    {
        // Weights for linear interpolation
        float wP = dzD / (dz + dzD);
        float wD = 1.0f - wP;
        
        float DInv = wP * (1 / DField[P].z) + wD * (1 / DField[D].z);
        presCorrectTerm -= (dv / den) * DInv / (0.5 * dz + 0.5 * dzD) * presCorrectFieldLastIter[D];
    }
    
    presCorrectField[id] = (1 / DFieldPresCorrect[id]) * (presCorrectTerm + bFieldPresCorrect[id]);
}

[numthreads(8, 8, 8)]
void CSApplyPresCorrection(uint3 id : SV_DispatchThreadID)
{
    int x = id.x, y = id.y, z = id.z;
    
    if (!InRegion(id))
        return;
    
    if (flagField[int3(x, y, z)] == CELL_SOLID)
        return;
    
    presFieldLastTime[id] += presCorrectField[id];
}

[numthreads(8, 8, 8)]
void CSPresNormalization(uint3 id : SV_DispatchThreadID)
{
    int x = id.x, y = id.y, z = id.z;
    
    if (!InRegion(id))
        return;
    
    if (flagField[int3(x, y, z)] == CELL_SOLID)
        return;
    
    //float refPres = presFieldLastTime[int3(gridRes.x / 2, gridRes.y / 2, gridRes.z / 2)];
    //float refPres = presFieldLastTime[int3(2, 2, 2)];
    float refPres = presFieldLastTime[int3(2, gridRes.y / 2, 2)];
    
    presFieldLastTime[id] -= refPres;
}

[numthreads(8, 8, 8)]
void CSApplyVelCorrectionDivergenceTheorem(uint3 id : SV_DispatchThreadID)
{
    int x = id.x, y = id.y, z = id.z;
    
    if (!InRegion(id))
        return;
    
    if (flagField[int3(x, y, z)] != CELL_FLUID)
        return;
    
    int3 P = int3(x, y, z);
    int3 E = int3(x + 1, y, z);
    int3 W = int3(x - 1, y, z);
    int3 N = int3(x, y + 1, z);
    int3 S = int3(x, y - 1, z);
    int3 U = int3(x, y, z + 1);
    int3 D = int3(x, y, z - 1);
    
    // Grid spacings
    float dx = facePosX[x + 1] - facePosX[x];
    float dy = facePosY[y + 1] - facePosY[y];
    float dz = facePosZ[z + 1] - facePosZ[z];
    float dsx = dy * dz; // Area of surface perpendicular to x
    float dsy = dx * dz; // Area of surface perpendicular to y
    float dsz = dx * dy; // Area of surface perpendicular to z
    float dv = dx * dy * dz;
    
    // Neighbor grid spacings
    float dxE = dx, dxW = dx, dyN = dy, dyS = dy, dzU = dz, dzD = dz;
    if (InRegion(E))
        dxE = facePosX[x + 2] - facePosX[x + 1];
    if (InRegion(W))
        dxW = facePosX[x] - facePosX[x - 1];
    if (InRegion(N))
        dyN = facePosY[y + 2] - facePosY[y + 1];
    if (InRegion(S))
        dyS = facePosY[y] - facePosY[y - 1];
    if (InRegion(U))
        dzU = facePosZ[z + 2] - facePosZ[z + 1];
    if (InRegion(D))
        dzD = facePosZ[z] - facePosZ[z - 1];
    
    float Dx = DField[P].x;
    float Dy = DField[P].y;
    float Dz = DField[P].z;

    // Cases (we use pe as an abbr of peCorrect):
    // 1. E == fluid: pe = wP * pP + wE * pE
    // 2. E == solid: pe = pP
    // 3. E == boundary:
    //   3.1. Fixed value: pe = 0
    //   3.2. Zero-gradient or symmetry: pe = pP
    
    float velXCorrect = 0, velYCorrect = 0, velZCorrect = 0;
    
    float peCorrect = 0, pwCorrect = 0, pnCorrect = 0, psCorrect = 0, puCorrect = 0, pdCorrect = 0;
    //float dpdxE = 0, dpdxW = 0, dpdyN = 0, dpdyS = 0, dpdzU = 0, dpdzD = 0;
    
    if (InRegion(E))
    {
        if (IsFluid(E))
        {
            // Weights for linear interpolation
            float wP = dxE / (dx + dxE);
            float wE = 1.0f - wP;
            
            peCorrect = wP * presCorrectField[P] + wE * presCorrectField[E];
            //dpdxE = (presCorrectField[E] - presCorrectField[P]) / (0.5 * dx + 0.5 * dxE);
        }
        else
        {
            peCorrect = presCorrectField[P];
            //dpdxE = 0;
        }
    }
    else
    {
        if (presBndTypeXn == PRES_BND_FIXED_VALUE)
        {
            peCorrect = 0;
            //dpdxE = -presCorrectField[P] / (0.5 * dx);
        }
        else if (presBndTypeXn == PRES_BND_ZERO_GRAD || presBndTypeXn == PRES_BND_SYMMETRY)
        {
            peCorrect = presCorrectField[P];
            //dpdxE = 0;
        }
    }
    
    if (InRegion(W))
    {
        if (IsFluid(W))
        {
            // Weights for linear interpolation
            float wP = dxW / (dx + dxW);
            float wW = 1.0f - wP;
            
            pwCorrect = wP * presCorrectField[P] + wW * presCorrectField[W];
        }
        else
            pwCorrect = presCorrectField[P];
    }
    else
    {
        if (presBndTypeX0 == PRES_BND_FIXED_VALUE)
        {
            pwCorrect = 0;
        }
        else if (presBndTypeX0 == PRES_BND_ZERO_GRAD)
        {
            pwCorrect = presCorrectField[P];
        }
        else if (presBndTypeX0 == PRES_BND_SYMMETRY)
        {
            pwCorrect = presCorrectField[P];
        }
    }
    
    if (InRegion(N))
    {
        if (IsFluid(N))
        {
            // Weights for linear interpolation
            float wP = dyN / (dy + dyN);
            float wN = 1.0f - wP;
            
            pnCorrect = wP * presCorrectField[P] + wN * presCorrectField[N];
        }
        else
            pnCorrect = presCorrectField[P];
    }
    else
    {
        if (presBndTypeYn == PRES_BND_FIXED_VALUE)
        {
            pnCorrect = 0;
        }
        else if (presBndTypeYn == PRES_BND_ZERO_GRAD)
        {
            pnCorrect = presCorrectField[P];
        }
        else if (presBndTypeYn == PRES_BND_SYMMETRY)
        {
            pnCorrect = presCorrectField[P];
        }
    }
    
    if (InRegion(S))
    {
        if (IsFluid(S))
        {
            // Weights for linear interpolation
            float wP = dyS / (dy + dyS);
            float wS = 1.0f - wP;
            
            psCorrect = wP * presCorrectField[P] + wS * presCorrectField[S];
        }
        else
            psCorrect = presCorrectField[P];
    }
    else
    {
        if (presBndTypeY0 == PRES_BND_FIXED_VALUE)
        {
            psCorrect = 0;
        }
        else if (presBndTypeY0 == PRES_BND_ZERO_GRAD)
        {
            psCorrect = presCorrectField[P];
        }
        else if (presBndTypeY0 == PRES_BND_SYMMETRY)
        {
            psCorrect = presCorrectField[P];
        }
    }
    
    if (InRegion(U))
    {
        if (IsFluid(U))
        {
            // Weights for linear interpolation
            float wP = dzU / (dz + dzU);
            float wU = 1.0f - wP;
            
            puCorrect = wP * presCorrectField[P] + wU * presCorrectField[U];
        }
        else
            puCorrect = presCorrectField[P];
    }
    else
    {
        if (presBndTypeZn == PRES_BND_FIXED_VALUE)
        {
            puCorrect = 0;
        }
        else if (presBndTypeZn == PRES_BND_ZERO_GRAD)
        {
            puCorrect = presCorrectField[P];
        }
        else if (presBndTypeZn == PRES_BND_SYMMETRY)
        {
            puCorrect = presCorrectField[P];
        }
    }
    
    if (InRegion(D))
    {
        if (IsFluid(D))
        {
            // Weights for linear interpolation
            float wP = dzD / (dz + dzD);
            float wD = 1.0f - wP;
            
            pdCorrect = wP * presCorrectField[P] + wD * presCorrectField[D];
        }
        else
            pdCorrect = presCorrectField[P];
    }
    else
    {
        if (presBndTypeZ0 == PRES_BND_FIXED_VALUE)
        {
            pdCorrect = 0;
        }
        else if (presBndTypeZ0 == PRES_BND_ZERO_GRAD)
        {
            pdCorrect = presCorrectField[P];
        }
        else if (presBndTypeZ0 == PRES_BND_SYMMETRY)
        {
            pdCorrect = presCorrectField[P];
        }
    }
    
    velXCorrect = -(dv / den) * (1 / Dx) * (peCorrect - pwCorrect) / dx;
    velYCorrect = -(dv / den) * (1 / Dy) * (pnCorrect - psCorrect) / dy;
    velZCorrect = -(dv / den) * (1 / Dz) * (puCorrect - pdCorrect) / dz;
    
    //velXCorrectEFace = -(dv / den) * (1 / Dx) * dpdxE;
    
    //velFaceFluxField[id] -= (1 / Dx) * dpdxE;
    
    velCorrectField[id] = float4(velXCorrect, velYCorrect, velZCorrect, 0.0f);
    velField[id] += float4(velXCorrect, velYCorrect, velZCorrect, 0.0f);
}

[numthreads(8, 8, 8)]
void CSComputeVelPredictResidual(uint3 id : SV_DispatchThreadID, uint3 groupId : SV_GroupID, uint3 groupThreadId : SV_GroupThreadID)
{
    int x = id.x, y = id.y, z = id.z;
    
    float3 locRes = float3(0, 0, 0);
    
    // Calculate squared residual
    if (x < gridRes.x && y < gridRes.y && z < gridRes.z)
    {
        locRes.x = DField[id].x * (velField[id].x - velFieldLastIter[id].x);
        locRes.y = DField[id].y * (velField[id].y - velFieldLastIter[id].y);
        locRes.z = DField[id].z * (velField[id].z - velFieldLastIter[id].z);
    }

    float locResSumSqu = pow(locRes.x, 2) + pow(locRes.y, 2) + pow(locRes.z, 2);
    
    // Store current squared residual
    uint groupThreadIndex = groupThreadId.z * (groupSize.x * groupSize.y) + groupThreadId.y * groupSize.x + groupThreadId.x;
    groupResBuf[groupThreadIndex] = locResSumSqu;
    
    GroupMemoryBarrierWithGroupSync();
    
    // Reduction on current thread group
    for (uint stride = (groupSize.x * groupSize.y * groupSize.z) / 2; stride > 0; stride /= 2)
    {
        if (groupThreadIndex < stride)
        {
            groupResBuf[groupThreadIndex] += groupResBuf[groupThreadIndex + stride];
        }
        GroupMemoryBarrierWithGroupSync();
    }
    
    // Save the current group result to the global buffer
    if (groupThreadIndex == 0)
    {
        int idGloResBuf = groupId.z * (numGroups.x * numGroups.y) + groupId.y * numGroups.x + groupId.x;
        gloResBuf[idGloResBuf] = groupResBuf[0];
    }
}

[numthreads(8, 8, 8)]
void CSComputePresCorrectResidual(uint3 id : SV_DispatchThreadID, uint3 groupId : SV_GroupID, uint3 groupThreadId : SV_GroupThreadID)
{
    int x = id.x, y = id.y, z = id.z;
    
    float locRes = 0;
    
    // Calculate squared residual
    if (x < gridRes.x && y < gridRes.y && z < gridRes.z)
        locRes = DFieldPresCorrect[id] * (presCorrectField[id] - presCorrectFieldLastIter[id]);

    float locResSumSqu = pow(locRes, 2);
    
    // Store current squared residual
    uint groupThreadIndex = groupThreadId.z * (groupSize.x * groupSize.y) + groupThreadId.y * groupSize.x + groupThreadId.x;
    groupResBuf[groupThreadIndex] = locResSumSqu;
    
    GroupMemoryBarrierWithGroupSync();
    
    // Reduction on current thread group
    for (uint stride = (groupSize.x * groupSize.y * groupSize.z) / 2; stride > 0; stride /= 2)
    {
        if (groupThreadIndex < stride)
        {
            groupResBuf[groupThreadIndex] += groupResBuf[groupThreadIndex + stride];
        }
        GroupMemoryBarrierWithGroupSync();
    }
    
    // Save the current group result to the global buffer
    if (groupThreadIndex == 0)
    {
        int idGloResBuf = groupId.z * (numGroups.x * numGroups.y) + groupId.y * numGroups.x + groupId.x;
        gloResBuf[idGloResBuf] = groupResBuf[0];
    }
}
